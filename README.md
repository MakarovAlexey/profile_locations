profile_locations
=====

An OTP library

Build
-----

    $ rebar3 compile

Описание
-------------

Источник данных представляет собой набор баз ланных. Часть данных в кластере Кассандры, часть данных в PostgreSQL. Данные в Pg разбиты на шарды. Каждый шард в своей схеме базы данных. Кроме того, базы храняться на разных серверах. Чтобы тащить данные из Pg быстро, необходимо обеспечить их получение по нескольким соединениям на сервер. Для доступа к Кассендре все проще, достаточно организовать асинхорнный доступ ограничив количество одновременных запросов (чтобы в случае, когда запросов ~100 000 не поймать time outs).

Данные нужно было тащить для проведения определенной аналитической работы. Для того, чтобы выполнять аналитику, выгружал данные в локальную базу PostgreSQL и выполнял требуемые манипуляции с данными уже в ней. Особых алгоритмов аналитики в проекте не представлено (только в profile_locations.erl, но его не смотри, там просто сборная солянка). Хочу обратить твое внимание именно модули доступа к базам, но, на всякий случай привожу описание всех модулей.

МОДУЛИ
------

ng_query.erl - модуль получения данных из Кассандры асинхронно.

Функции

new(StatementName) -> {ok, Ref}

Ref = ref() - ссылка на процесс запроса

Старт процесса запроса. В качестве аргумента передается имя предопределенного запроса (prepared statement) который указывается в файле settings.config.

execute(Ref, Parameters) -> ok
execute(Ref, Parameters, Fun) -> ok

Ref = ref() - ссылка на процесс запроса
Parameters = [term()] - параметры запроса
Fun = fun((Result :: T) -> term())

Отправить запрос в кластер. В качестве дополнительного параметра можно указать функцию, которая будет применена к результату данного запроса. Результаты запросов накапливаются в список.

close(Ref) -> [term()]
close(Ref, Fun1) -> [term()]
close(Ref, Fun2, Acc0) -> [term()]

Ref = ref() - ссылка на процесс запроса
Fun1 = fun((Result :: [T]) -> term())
Fun2 = fun((Result :: [T], Acc) -> term())
Acc0 = term()
Acc = ter()

close/1 - окончить работу с запросом. Функция возвращает список результатов запросов.

close/2 - окончить работу с запросом и применить функцию Fun, аргументом будет список результатов.

close/2 - окончить работу с запросом и применить функцию Fun, аналогичной вызову lists:foldl для результата.

ng_queue.erl - модуль очереди запросов к Кассандре, нужен, чтобы ограничить количество одновременных асинхронных запросов. Напрямую не используется. В файле settings.config можно указать количество одновременных запросов к базе.

parallel.erl - модуль для параллельной обработки.

Функции и поведение аналогичны функциям ng_query.erl. Нужен для распараллеливания вычислений.

parallel_queue.erl - модуль очереди параллельных задач. Аналогичен ng_queue.erl

parallel_worker.erl - модуль процесса выполняющего параллельные задачи. Напрямую не используется.

pgc_connection.erl - модуль инкапсулирующий процесс подключения epgsql и prepared statements. Напрямую неиспользуется.

pgc_query.erl - модуль процесса накапливающий результаты запросов к шардам. Поведение аналогично ng_query.erl. Хотел управлять длиной очереди динамически (чтобы не накапливались необработанные результаты от серверов, которые просто бы занимали оперативную память), в зависимости от времени выполнения запросов и выремени выполнения функции, котороую можно применить к каждому результату, но это работает плохо, проще сделать модуль, аналогичный с ng_queue.erl, который бы ограничил количество результатов запросов, которые ожидают обработки.

pgc_server.erl - модуль представляет сервер постгреса. Инкапсулирует подключения к базе, а также очередь запросов (с учетом диска и его освобождения диска для записи). Поскольку шарды физически расположены на разных дисках сервера, то желательно одновременно производить запросы к шардам, которые расположены на разных дисках, кроме того, постараться не производить последовательно, нескольких запросов к шардам одного диска, а отправить запрос к шарду на другом диске (round-robbin). 

shard.erl - модуль представляет шард, через него производится запрос к базе.

query(ShardNumber, Query, TypedParameters) -> Ref

ShardNumber = integer - номер шарда
Query = String - строка запроса. Если предварить названия таблиц конструкцией "{shard}.", то вместо "{shard}" будет подставлено название шарда (схемы)
TypedParameters = [{Type, Value}] - список типизированных параметров, такой какой "понимает" epgsql

shards.erl - модуль представляет общие действия над шардами, по сути, там только функция foreach.

foreach(Fun) -> ok - обходит все номера шардов и вызывает переданную функцию.

Fun = fun((ShardNumber) -> term())

registry.erl - реализация локального регистра для процессов. Стандартный регистр "local", может использовать только символы, а этот регистр нужен, чтобы использовать термы. Предполагал, что это поможет избавиться от Pid процессов в коде и, в дальнейшем, осмысленно использовать перезапуск процессов.

sharded.erl - модуль использоваться для попытки использовать DETS для временного хранения результатов запросов.

postgresql_file.erl - записывает информацию в файл, для команды COPY PostgreSQL, в бинарном формате.

profile_id.erl - управляет загрузкой опредделнных данных из шардов. Пример можно посмотреть в модуле profile_locations.erl, в функции load_to_binary/1.

profile_locations.erl - тут код всех экспериментов, поэтому прошу не рассматривать данный модуль.

Модули *_sup.erl, это супервизоры для приведенных модулей.

setting.config - файл настроек.
